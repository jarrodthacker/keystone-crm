# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  name: String
  email: String
  password: PasswordState
  supportRequests(
    where: SupportRequestWhereInput! = {}
    orderBy: [SupportRequestOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [SupportRequest!]
  supportRequestsCount(where: SupportRequestWhereInput! = {}): Int
}

type PasswordState {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  supportRequests: SupportRequestManyRelationFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input SupportRequestManyRelationFilter {
  every: SupportRequestWhereInput
  some: SupportRequestWhereInput
  none: SupportRequestWhereInput
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  supportRequests: SupportRequestRelateToManyForUpdateInput
}

input SupportRequestRelateToManyForUpdateInput {
  disconnect: [SupportRequestWhereUniqueInput!]
  set: [SupportRequestWhereUniqueInput!]
  create: [SupportRequestCreateInput!]
  connect: [SupportRequestWhereUniqueInput!]
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  password: String
  supportRequests: SupportRequestRelateToManyForCreateInput
}

input SupportRequestRelateToManyForCreateInput {
  create: [SupportRequestCreateInput!]
  connect: [SupportRequestWhereUniqueInput!]
}

type Organization {
  id: ID!
  name: String
  contacts(
    where: ContactWhereInput! = {}
    orderBy: [ContactOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Contact!]
  contactsCount(where: ContactWhereInput! = {}): Int
  funding(
    where: FundingWhereInput! = {}
    orderBy: [FundingOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Funding!]
  fundingCount(where: FundingWhereInput! = {}): Int
  requirements(
    where: RequirementWhereInput! = {}
    orderBy: [RequirementOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Requirement!]
  requirementsCount(where: RequirementWhereInput! = {}): Int
  city: String
  state: String
  country: String
  joined: CalendarDay
  supportRequests(
    where: SupportRequestWhereInput! = {}
    orderBy: [SupportRequestOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [SupportRequest!]
  supportRequestsCount(where: SupportRequestWhereInput! = {}): Int
}

scalar CalendarDay
  @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input OrganizationWhereUniqueInput {
  id: ID
}

input OrganizationWhereInput {
  AND: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
  id: IDFilter
  name: StringFilter
  contacts: ContactManyRelationFilter
  funding: FundingManyRelationFilter
  requirements: RequirementManyRelationFilter
  city: StringFilter
  state: StringFilter
  country: StringFilter
  joined: CalendarDayNullableFilter
  supportRequests: SupportRequestManyRelationFilter
}

input ContactManyRelationFilter {
  every: ContactWhereInput
  some: ContactWhereInput
  none: ContactWhereInput
}

input FundingManyRelationFilter {
  every: FundingWhereInput
  some: FundingWhereInput
  none: FundingWhereInput
}

input RequirementManyRelationFilter {
  every: RequirementWhereInput
  some: RequirementWhereInput
  none: RequirementWhereInput
}

input CalendarDayNullableFilter {
  equals: CalendarDay
  in: [CalendarDay!]
  notIn: [CalendarDay!]
  lt: CalendarDay
  lte: CalendarDay
  gt: CalendarDay
  gte: CalendarDay
  not: CalendarDayNullableFilter
}

input OrganizationOrderByInput {
  id: OrderDirection
  name: OrderDirection
  city: OrderDirection
  state: OrderDirection
  country: OrderDirection
  joined: OrderDirection
}

input OrganizationUpdateInput {
  name: String
  contacts: ContactRelateToManyForUpdateInput
  funding: FundingRelateToManyForUpdateInput
  requirements: RequirementRelateToManyForUpdateInput
  city: String
  state: String
  country: String
  joined: CalendarDay
  supportRequests: SupportRequestRelateToManyForUpdateInput
}

input ContactRelateToManyForUpdateInput {
  disconnect: [ContactWhereUniqueInput!]
  set: [ContactWhereUniqueInput!]
  create: [ContactCreateInput!]
  connect: [ContactWhereUniqueInput!]
}

input FundingRelateToManyForUpdateInput {
  disconnect: [FundingWhereUniqueInput!]
  set: [FundingWhereUniqueInput!]
  create: [FundingCreateInput!]
  connect: [FundingWhereUniqueInput!]
}

input RequirementRelateToManyForUpdateInput {
  disconnect: [RequirementWhereUniqueInput!]
  set: [RequirementWhereUniqueInput!]
  create: [RequirementCreateInput!]
  connect: [RequirementWhereUniqueInput!]
}

input OrganizationUpdateArgs {
  where: OrganizationWhereUniqueInput!
  data: OrganizationUpdateInput!
}

input OrganizationCreateInput {
  name: String
  contacts: ContactRelateToManyForCreateInput
  funding: FundingRelateToManyForCreateInput
  requirements: RequirementRelateToManyForCreateInput
  city: String
  state: String
  country: String
  joined: CalendarDay
  supportRequests: SupportRequestRelateToManyForCreateInput
}

input ContactRelateToManyForCreateInput {
  create: [ContactCreateInput!]
  connect: [ContactWhereUniqueInput!]
}

input FundingRelateToManyForCreateInput {
  create: [FundingCreateInput!]
  connect: [FundingWhereUniqueInput!]
}

input RequirementRelateToManyForCreateInput {
  create: [RequirementCreateInput!]
  connect: [RequirementWhereUniqueInput!]
}

type SupportRequest {
  id: ID!
  name: String
  issue: String
  date: DateTime
  status: String
  organization: Organization
  technician: User
}

scalar DateTime
  @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input SupportRequestWhereUniqueInput {
  id: ID
}

input SupportRequestWhereInput {
  AND: [SupportRequestWhereInput!]
  OR: [SupportRequestWhereInput!]
  NOT: [SupportRequestWhereInput!]
  id: IDFilter
  name: StringFilter
  issue: StringFilter
  date: DateTimeNullableFilter
  status: StringNullableFilter
  organization: OrganizationWhereInput
  technician: UserWhereInput
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input SupportRequestOrderByInput {
  id: OrderDirection
  name: OrderDirection
  issue: OrderDirection
  date: OrderDirection
  status: OrderDirection
}

input SupportRequestUpdateInput {
  name: String
  issue: String
  date: DateTime
  status: String
  organization: OrganizationRelateToOneForUpdateInput
  technician: UserRelateToOneForUpdateInput
}

input OrganizationRelateToOneForUpdateInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
  disconnect: Boolean
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input SupportRequestUpdateArgs {
  where: SupportRequestWhereUniqueInput!
  data: SupportRequestUpdateInput!
}

input SupportRequestCreateInput {
  name: String
  issue: String
  date: DateTime
  status: String
  organization: OrganizationRelateToOneForCreateInput
  technician: UserRelateToOneForCreateInput
}

input OrganizationRelateToOneForCreateInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type Requirement {
  id: ID!
  name: String
  description: String
  date: CalendarDay
  status: String
  jiraUrl: String
  application: String
  organization: Organization
  contact: Contact
}

input RequirementWhereUniqueInput {
  id: ID
}

input RequirementWhereInput {
  AND: [RequirementWhereInput!]
  OR: [RequirementWhereInput!]
  NOT: [RequirementWhereInput!]
  id: IDFilter
  name: StringFilter
  description: StringFilter
  date: CalendarDayNullableFilter
  status: StringNullableFilter
  jiraUrl: StringFilter
  application: StringFilter
  organization: OrganizationWhereInput
  contact: ContactWhereInput
}

input RequirementOrderByInput {
  id: OrderDirection
  name: OrderDirection
  description: OrderDirection
  date: OrderDirection
  status: OrderDirection
  jiraUrl: OrderDirection
  application: OrderDirection
}

input RequirementUpdateInput {
  name: String
  description: String
  date: CalendarDay
  status: String
  jiraUrl: String
  application: String
  organization: OrganizationRelateToOneForUpdateInput
  contact: ContactRelateToOneForUpdateInput
}

input ContactRelateToOneForUpdateInput {
  create: ContactCreateInput
  connect: ContactWhereUniqueInput
  disconnect: Boolean
}

input RequirementUpdateArgs {
  where: RequirementWhereUniqueInput!
  data: RequirementUpdateInput!
}

input RequirementCreateInput {
  name: String
  description: String
  date: CalendarDay
  status: String
  jiraUrl: String
  application: String
  organization: OrganizationRelateToOneForCreateInput
  contact: ContactRelateToOneForCreateInput
}

input ContactRelateToOneForCreateInput {
  create: ContactCreateInput
  connect: ContactWhereUniqueInput
}

type Contact {
  id: ID!
  name: String
  type: String
  unsecurePhone: String
  unsecureEmail: String
  securePhone: String
  secureEmail: String
  organization: Organization
  requirements(
    where: RequirementWhereInput! = {}
    orderBy: [RequirementOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Requirement!]
  requirementsCount(where: RequirementWhereInput! = {}): Int
}

input ContactWhereUniqueInput {
  id: ID
}

input ContactWhereInput {
  AND: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
  id: IDFilter
  name: StringFilter
  type: StringNullableFilter
  unsecurePhone: StringFilter
  unsecureEmail: StringFilter
  securePhone: StringFilter
  secureEmail: StringFilter
  organization: OrganizationWhereInput
  requirements: RequirementManyRelationFilter
}

input ContactOrderByInput {
  id: OrderDirection
  name: OrderDirection
  type: OrderDirection
  unsecurePhone: OrderDirection
  unsecureEmail: OrderDirection
  securePhone: OrderDirection
  secureEmail: OrderDirection
}

input ContactUpdateInput {
  name: String
  type: String
  unsecurePhone: String
  unsecureEmail: String
  securePhone: String
  secureEmail: String
  organization: OrganizationRelateToOneForUpdateInput
  requirements: RequirementRelateToManyForUpdateInput
}

input ContactUpdateArgs {
  where: ContactWhereUniqueInput!
  data: ContactUpdateInput!
}

input ContactCreateInput {
  name: String
  type: String
  unsecurePhone: String
  unsecureEmail: String
  securePhone: String
  secureEmail: String
  organization: OrganizationRelateToOneForCreateInput
  requirements: RequirementRelateToManyForCreateInput
}

type Funding {
  id: ID!
  organization: Organization
  amount: Int
  date: CalendarDay
  fiscalYear: Int
}

input FundingWhereUniqueInput {
  id: ID
}

input FundingWhereInput {
  AND: [FundingWhereInput!]
  OR: [FundingWhereInput!]
  NOT: [FundingWhereInput!]
  id: IDFilter
  organization: OrganizationWhereInput
  amount: IntNullableFilter
  date: CalendarDayNullableFilter
  fiscalYear: IntNullableFilter
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntNullableFilter
}

input FundingOrderByInput {
  id: OrderDirection
  amount: OrderDirection
  date: OrderDirection
  fiscalYear: OrderDirection
}

input FundingUpdateInput {
  organization: OrganizationRelateToOneForUpdateInput
  amount: Int
  date: CalendarDay
  fiscalYear: Int
}

input FundingUpdateArgs {
  where: FundingWhereUniqueInput!
  data: FundingUpdateInput!
}

input FundingCreateInput {
  organization: OrganizationRelateToOneForCreateInput
  amount: Int
  date: CalendarDay
  fiscalYear: Int
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createOrganization(data: OrganizationCreateInput!): Organization
  createOrganizations(data: [OrganizationCreateInput!]!): [Organization]
  updateOrganization(
    where: OrganizationWhereUniqueInput!
    data: OrganizationUpdateInput!
  ): Organization
  updateOrganizations(data: [OrganizationUpdateArgs!]!): [Organization]
  deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
  deleteOrganizations(where: [OrganizationWhereUniqueInput!]!): [Organization]
  createSupportRequest(data: SupportRequestCreateInput!): SupportRequest
  createSupportRequests(data: [SupportRequestCreateInput!]!): [SupportRequest]
  updateSupportRequest(
    where: SupportRequestWhereUniqueInput!
    data: SupportRequestUpdateInput!
  ): SupportRequest
  updateSupportRequests(data: [SupportRequestUpdateArgs!]!): [SupportRequest]
  deleteSupportRequest(where: SupportRequestWhereUniqueInput!): SupportRequest
  deleteSupportRequests(
    where: [SupportRequestWhereUniqueInput!]!
  ): [SupportRequest]
  createRequirement(data: RequirementCreateInput!): Requirement
  createRequirements(data: [RequirementCreateInput!]!): [Requirement]
  updateRequirement(
    where: RequirementWhereUniqueInput!
    data: RequirementUpdateInput!
  ): Requirement
  updateRequirements(data: [RequirementUpdateArgs!]!): [Requirement]
  deleteRequirement(where: RequirementWhereUniqueInput!): Requirement
  deleteRequirements(where: [RequirementWhereUniqueInput!]!): [Requirement]
  createContact(data: ContactCreateInput!): Contact
  createContacts(data: [ContactCreateInput!]!): [Contact]
  updateContact(
    where: ContactWhereUniqueInput!
    data: ContactUpdateInput!
  ): Contact
  updateContacts(data: [ContactUpdateArgs!]!): [Contact]
  deleteContact(where: ContactWhereUniqueInput!): Contact
  deleteContacts(where: [ContactWhereUniqueInput!]!): [Contact]
  createFunding(data: FundingCreateInput!): Funding
  createFundings(data: [FundingCreateInput!]!): [Funding]
  updateFunding(
    where: FundingWhereUniqueInput!
    data: FundingUpdateInput!
  ): Funding
  updateFundings(data: [FundingUpdateArgs!]!): [Funding]
  deleteFunding(where: FundingWhereUniqueInput!): Funding
  deleteFundings(where: [FundingWhereUniqueInput!]!): [Funding]
  endSession: Boolean!
  authenticateUserWithPassword(
    email: String!
    password: String!
  ): UserAuthenticationWithPasswordResult
  createInitialUser(
    data: CreateInitialUserInput!
  ): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult =
    UserAuthenticationWithPasswordSuccess
  | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  password: String
}

type Query {
  users(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  organizations(
    where: OrganizationWhereInput! = {}
    orderBy: [OrganizationOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Organization!]
  organization(where: OrganizationWhereUniqueInput!): Organization
  organizationsCount(where: OrganizationWhereInput! = {}): Int
  supportRequests(
    where: SupportRequestWhereInput! = {}
    orderBy: [SupportRequestOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [SupportRequest!]
  supportRequest(where: SupportRequestWhereUniqueInput!): SupportRequest
  supportRequestsCount(where: SupportRequestWhereInput! = {}): Int
  requirements(
    where: RequirementWhereInput! = {}
    orderBy: [RequirementOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Requirement!]
  requirement(where: RequirementWhereUniqueInput!): Requirement
  requirementsCount(where: RequirementWhereInput! = {}): Int
  contacts(
    where: ContactWhereInput! = {}
    orderBy: [ContactOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Contact!]
  contact(where: ContactWhereUniqueInput!): Contact
  contactsCount(where: ContactWhereInput! = {}): Int
  fundings(
    where: FundingWhereInput! = {}
    orderBy: [FundingOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Funding!]
  funding(where: FundingWhereUniqueInput!): Funding
  fundingsCount(where: FundingWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  enableSignout: Boolean!
  enableSessionItem: Boolean!
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum QueryMode {
  default
  insensitive
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
